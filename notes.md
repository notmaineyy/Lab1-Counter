#### Department of Electrical & Electronic Engineering, Imperial College London


### EIE 2 Instruction Set Architecture & Compiler (IAC) 2022
---
### Shermaine Ang 


## Lab 1 – Learning System Verilog with Verilator and Vbuddy

#### 20 October 2022
### Task 1
---

### Problems Encountered
When writing the code for the testbench, we had errors that the files needed to be included (at the beginning) were not found. This was because the folder that we are working on had to be the top directory. Hence, we fixed that by changing our directory and it went smoothly.

#### Creating System Verilog file
Create a new System Verilog file (counter.sv) The schematic representation of this basic counter is shown below. It counts on the positive edge of clk if enable is ‘1’.  It is synchronously reset to 0 if rst is asserted. 

![counter](images/counter.jpg)

Note the following:
1.	The file name and the module name must be the same.
2.	The number of bits in the counter is specified with the parameter WIDTH. It is currently set to 8-bit. 
3.	The always_ff @ (posedge clk) is the way that one specifies a clocked circuit. 
4.	‘<=’ in line 12 and 13 are non-block assignments which should be used within an always_ff block.
5.	{WIDTH{1’b0}} in line 12 uses the concatenation operator { } to form WIDTH bits of ‘0’. (Can you explain the construct in line 13?)

Here is the mapping between System Verilog and the counter circuit "synthesized" via Verilator:

![counter interal](images/counter_inners.jpg)

#### Creating testbench file in C++
This has to be done before we can combine everything to make the executable model.  

This testbench file is a template for all other testbench files. It consists of various sections, which are mandatory (except for the trace dump section if you don’t want to see the waveforms).

![Testbench](images/counter_tb.jpg)

#### Compiling the System Verilog model with testbench
The following command was used on Terminal:
```bash
# run Verilator to translate Verilog into C++, including C++ testbench
verilator -Wall --cc --trace counter.sv --exe counter_tb.cpp
```

This runs Verilator to translate counter.sv into C++ code, and merge with **_counter_tb.cpp_** to produces a number of files in a new folder: **obj_dir**. It also automatically generates a **_.mk_** file called **_Vcounter.mk_**, which will produce the final simulation model **_Vcounter_**.

Next, this was entered:

```bash
# build C++ project via make automatically generated by Verilator
make -j -C obj_dir/ -f Vcounter.mk Vcounter
```

This makes **_Vcounter_**, which is the executable model of our counter!  

We are now ready to simulate by simply running **_Vcounter_**, which is again in the **_obj_dir/._** directory, by entering:

```bash
# run executable simulation file
obj_dir/Vcounter
```
In the folder task1, a file **_Vcounter.vcd_** has been generated.  This is the trace waveform file and contains the simulation results.

#### Plotting waveforms with GTKwave
I noticed that there were fewer problems encountered on MacOS, and by following the steps, I managed to get the expected wave as seen below:

![GTKWave](images/task1_gtkwave.png)

#### Why is the time axis in ps? Does it matter?
It does not matter

#### Waveform Description
2nd rising edge --> i=0

rst = 1 when i < 2 (when 0,1,2)

en = 1 when i > 4 (i==5)

#### Creation of shell script
This is a shortcut to avoid retyping all the commands to make the executable model.
Created a shell script doit.sh with the following
![bash script](images/doit.jpg)

We can now run all the commands in one go by typing:   
```bash
source ./doit.sh
```
## TEST YOURSELF CHALLENGE
1.	Modify the testbench so that you stop counting for 3 cycles once the counter reaches 0x9, and then resume counting.  You may also need to change the stimulus for _rst_.

The following changes were made:
![codechanges](images/task1_challenge1_change.png)

New GTKwave:
![newgtkwave](images/task1_challenge1_wave.png)

2.	The current counter has a synchronous reset. To implement asynchronous reset, you can change line 11 of counter.sv to detect change in _rst_ signal.  (See notes.) 

Asynchronous reset: Circuit should reset whenever reset signal is active 'Irrespective' of clock.

Changes made:
![resetchanges](images/task1_challenge2_change.png)

This causes the counter to not increase in the same clock cycle as the reset. Reset applies at the current rising edge of the clock. Comparatively for a synchoronous reset the reset only applies on the next rising edge of the clock.

#### Synchronous Reset
![before](images/task1_challenge2_bbefore.png)

#### Asynchronous Reset
![after](images/task1_challenge2_after.png)